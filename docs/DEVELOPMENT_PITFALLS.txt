================================================================================
  FACTORY MAPPING - 開發者避坑指南與資料結構說明
  (DEVELOPMENT PITFALLS & DATA STRUCTURE REFERENCE)
================================================================================

此文件記錄 HLOC/PyColmap 開發過程中極易踩到的「地雷」與底層資料結構細節。
若日後需修改核心演算法 (localization_engine.py)，請務必先閱讀此文件。

--------------------------------------------------------------------------------
1. H5 特徵檔 (.h5 Features) 的維度陷阱
--------------------------------------------------------------------------------
[檔案]: global-feats-*.h5
[問題]: 當 Query 只有 1 張圖時，numpy 的行為會導致維度消失。

* 正常情況 (N > 1):
  - h5_obj['global_descriptor'].__array__() 回傳 shape 為 (N, D)。
  
* 危險情況 (N = 1):
  - 讀出來可能是 (1, D)。
  - 若不小心用了 .squeeze() 或某些矩陣運算，它會變成 (D,) 的 1D 向量。
  - 後果: 在進行矩陣乘法 (torch.matmul 或 np.dot) 時，會因為維度不匹配而報錯，或算出錯誤的 Similarity。

[正確寫法]:
  vecs = np.array(vectors)
  if vecs.ndim == 1:
      vecs = vecs[np.newaxis, :]  # 強制轉為 (1, D) 確保是 2D 陣列

--------------------------------------------------------------------------------
2. H5 匹配檔 (.h5 Matches) 的 Key 命名規則
--------------------------------------------------------------------------------
[檔案]: matches-*.h5, db-matches-*.h5
[問題]: HLOC 內部會對圖片路徑進行編碼，導致用原始檔名找不到 Key。

* 原始檔名: "db/frame_001.jpg"
* H5 內部的 Group Key 可能變成:
  1. "db-frame_001.jpg" (斜線被換成 Dash)
  2. "db_frame_001.jpg" (斜線被換成 Underscore)
  3. "query_dir/db_dir" (層級結構)

[解決方案]:
  不要只用 `if name in h5_file` 檢查。
  必須實作「模糊搜尋」或「多種編碼嘗試」：
  - 嘗試 "a/b"
  - 嘗試 "a-b"
  - 嘗試 "a_b"

--------------------------------------------------------------------------------
3. 定位 Log 檔 (.pkl) 的巢狀結構
--------------------------------------------------------------------------------
[檔案]: results_*.txt_logs.pkl
[問題]: 這不是一個扁平的 Dictionary，直接 Iterate 會讀錯資料。

* 結構範例:
  {
      "features": "path/to/feats.h5",
      "matches": "path/to/matches.h5",
      "loc": {  <--- 真正的資料藏在這裡 (Root Key)
          "query_img_01.jpg": {
              "PnP_ret": {
                  "success": True,
                  "num_inliers": 218,
                  "qvec": ...
              }
          }
      }
  }

[注意]: 讀取時必須先檢查 `data.get('loc')` 是否存在，再進入迴圈。

--------------------------------------------------------------------------------
4. PyColmap 的回傳型別地獄 (Return Types)
--------------------------------------------------------------------------------
[函式]: pycolmap.estimate_and_refine_absolute_pose()
[問題]: 不同版本的 pycolmap (或不同安裝方式) 回傳的物件完全不同。

* 舊版 (Dict):
  回傳 {'success': True, 'num_inliers': 100, 'qvec': ...}

* 新版 (Object):
  回傳一個 Class Instance。
  屬性存取方式: ret.success, ret.num_inliers, ret.cam_from_world.rotation...

[解決方案]:
  程式碼必須同時相容兩者 (Duck Typing):
  if isinstance(ret, dict):
      success = ret.get('success')
  else:
      success = ret.success

--------------------------------------------------------------------------------
5. 旋轉四元數順序 (Quaternion Order) - 最致命的錯誤
--------------------------------------------------------------------------------
[問題]: 數學庫之間的定義不同，導致座標轉換後位置全錯。

* Eigen / PyColmap 內部:
  - 順序: [x, y, z, w] (Imaginary first)
  - 特徵: 實部 w 在最後。

* COLMAP 檔案 / HLOC / Scipy:
  - 順序: [w, x, y, z] (Real first)
  - 特徵: 實部 w 在最前。

[判斷法]:
  通常 w 是最大的值 (接近 1 或 0.5 以上)。
  如果你的結果是 [0.01, 0.02, 0.01, 0.99]，那 0.99 肯定就是 w。
  這代表它是 [x, y, z, w] 格式。

[正確操作]:
  從 pycolmap 拿到 q (x,y,z,w) 後，必須手動轉為 (w,x,y,z) 才能存入 results.txt 或傳給 Scipy 計算。
  q_final = [q[3], q[0], q[1], q[2]]

--------------------------------------------------------------------------------
6. 影像縮放 (Resize) 與座標還原
--------------------------------------------------------------------------------
[問題]: Server 端 Resize 圖片後，算出的 P2D 是縮小版的，直接拿去算 PnP 會失敗。

[流程]:
  1. 原始尺寸 (W, H) -> Resize (NewW, NewH)
  2. 特徵提取 -> 得到 Keypoints (在 NewW, NewH 座標系上)
  3. 還原座標 -> 必須乘上 scale 回到 (W, H)
  
  公式:
  scale_x = W / NewW
  kpt_orig_x = (kpt_new_x + 0.5) * scale_x - 0.5
  (加上 0.5 是為了對齊 Pixel Center 定義)

================================================================================